* API
** thread.h
*** Globals
#+BEGIN_SRC C
struct thcStruct threadArray[33]; 
#+END_SRC
*** Datenstrukturen
**** enum Status
#+BEGIN_SRC C
enum thcStatus{

}
#+END_SRC
**** struct THC
     + Alle Register (R0-R15)
     + SPSR
     + enum Status
#+BEGIN_SRC C
struct thcStruct{

}
#+END_SRC
*** Functions
**** initThreadArray
- Iteriert über Elemente
  - Setzt SPs
  - Setzt die ersten 32 Elemente auf Dead
  - Das letzte (Idle Thread) wird auf Idle Scheisse intialisiert
#+BEGIN_SRC C
void initThreadArray();
#+END_SRC
**** Kopiere Stack saved Regs to THC
- Kopiere die durch das Trampolin gesaveten Regs R0-R15
#+BEGIN_SRC C
void cpyStackToTHC();
#+END_SRC
**** createThread
-
#+BEGIN_SRC C
void createThread(void (*func)(void *), const void * args, int args_size);
#+END_SRC
**** startThread
- Wird als Programcounter in THC reingeschrieben (passiert in createThread)

- Sucht sich auf dem entsprechenden Stack die Argumente zusammen
- Callt den FunctionPointer der in R0 drinsteht mit den vorher zusammengesuchten Arugmenten
#+BEGIN_SRC C
void startThread();
#+END_SRC
** sheduler.h
*** Defines 
#+BEGIN_SRC C
#define timeSliceInterrupts 10;
#+END_SRC
*** Globals
**** timerInterruptCount
- Zählt die Timer Interrupts
- Bei timeSliceInterrupts wird der Kontext gewechselt
#+BEGIN_SRC C
static uint16_t timerInterruptCount = 0;
#+END_SRC
*** Functions
**** rrSchedule
- Checken ob ein Ding gestorben ist
  - Wenn ja:
    + timerInterruptCount = 0
    + Suche Interativ ab currentThread, welcher Thread pending ist
      + Wenn Nix pending ist -> Idle Thread -> Nummer 32
  - Wenn nein:
    + Wenn timerInterruptCount >= timeSliceInterrupts
      + timerInterruptCount = 0
      + Suche Interativ ab currentThread, welcher Thread pending ist
        + Wenn Nix pending ist -> Idle Thread -> Nummer 32
      + return den gefundenen neuen
    + Else
      + return currentThread

- threadDied: 1 in case current running thread died, otherwise 0  
#+BEGIN_SRC C
uint8_t rrSchedule(uint8_t currentThread, uint8_t threadDied, );
#+END_SRC

** handler.h
*** Functions
**** restoreContext
#+BEGIN_SRC C
void restoreContext(struct thcStruct*)
#+END_SRC
* General Notes
** Notes

- Timer Interrupt erhöht timerInterruptCount um 1

*** SWI Handler
- Kommt SWI vom OS oder vom User
  - Check über Mode im SPSR
  - Wenn vom OS:
    + printRegDump
    + Abschmieren
  - Wenn vom User
    + Verändere THC -> currentThread auf Dead stellen
    + rrScheduler(currentThread, 1);
    + restoreContext();

*** IRQ Handler
- Im Timer Interrupt Handler
  - rrScheduler(getCurrentThread(), 0);
  - Wenn return vom Scheduler was anderes als getCurrentThread() dann 

** TODO getCurrentThread
